---
published: false
layout: post
title: "对比学习综述"
categories: 我的AI新书
date: 2023-09-21 00:00:00 +0800
excerpt: "对比学习综述"
---


对比学习综述



发展历程大概可以分为四个阶段



1、百花齐放

InstDisc（instance discrimination）
CPC
CMC
在这个阶段中，方法、模型、目标函数、代理任务都还没有统一，所以说是一个百花齐放的时代


2、CV双雄

MoCo v1
SimCLR v1
MoCo v2
SimCLR v2
CPC、CMC的延伸工作
SwAV
这个阶段发展非常迅速，上述工作有的间隔一两个月，有的间隔甚至不到一个月，ImageNet上的成绩基本上每个月都在被刷新


3、不用负样本

BYOL以及它后续的一些改进
最后SimSiam将所有的方法都归纳总结了一下，融入到了SimSiam的框架中，基本上是用卷积神经网络做对比学习的一个总结性工作


4、transformer

MoCo v3
DINO
对于自监督学习来说，无论是对比学习还是最新的掩码学习，都是用Vision Transformer做的


这里只是把最有联系的一些工作串到一起，讲述他们的相似之处和不同之处









1、百花齐放



Unsupervised Feature Learning via Non-Parametric Instance Discrimination



InstDisc（instance discrimination）



这篇论文提出了个体判别任务以及memory bank




图1:本文的方法是受到有监督学习结果的启发，如果将一张豹子的图片喂给一个已经用有监督学习方式训练好的分类器，会发现他给出来的分类结果排名前几的全都是跟豹子相关的，有猎豹、雪豹，总之从图片来看这些物体都是长非常相近的；而排名靠后的那些判断往往是跟豹子一点关系都没有的类别
通过很多这样的现象，作者觉得让这些图片聚集在一起的原因并不是因为它们有相似的语义标签，而是因为这些照片长得太像了，某一些 object 就是很相似，它们跟另外一些 object 的呢就是不相似，所以才会导致有些分类分数都很高，而有些分数非常低
最后作者根据这个观察提出了个体判别任务：无监督的学习方式就是把按照类别走的有监督信号推到了极致，现在把每一个 instance都看成是一个类别，也就是每一张图片都看作是一个类别，目标是能学一种特征能把每一个图片都区分开来
所以图一画的很好，起到了一石二鸟的作用：不仅很简单的介绍了研究动机，自然而然地引入了问题，而且用一句话的形式引入了个体判别这个代理任务



图二讲述了文章中的方法
通过一个卷积神经网络把所有的图片都编码成一个特征（这些特征在最后的特征空间里能够尽可能的分开，因为对于个体判别任务来说每个图片都是自己的类，所以说每个图片都应该和别的图片尽量的分开）
训练这个卷积神经网络使用的是对比学习，所以需要有正样本和负样本，根据个体判别这个任务，正样本就是这个图片本身（可能经过一些数据增强），负样本就是数据集里所有其它的图片
做对比学习，大量的负样本特征到底应该存在哪呢？本文用了 memory bank 的形式：就是说把所有图片的特征全都存到memory bank 里，也就是一个字典（ImageNet数据集有128万的图片，也就是说memory bank里要存128万行，也就意味着每个特征的维度不能太高，否则存储代价太大了，本文用的是128维）
前向过程：

假如batch size是256，也就是说有256个图片进入到编码器中，通过一个 Res 50，最后的特征维度是2048维，然后把它降维降到128维，这就是每个图片的特征大小
batch size 是 256 的话也就意味着有256个正样本，那负样本从哪来呢？自然是从 memory bank 里随机地抽一些负样本出来。本文抽了4,096个负样本出来
有了正样本也有了负样本，就可以用NCE loss 计算对比学习的目标函数
一旦更新完这个网络，就可以把 mini batch里的数据样本所对应的那些特征，在 memory bank 里更换掉，这样 memory bank 就得到了更新
接下来就是反复这个过程，不停的去更新这个编码 t，不停的更新这个 memory bank，最后学到这个特征尽可能的有区分性
本文的方法还有很多细节都设计的非常巧妙

比如说 proximal regularization：它给模型的训练加了一个约束，从而能让 memory bank 里的那些特征进行动量式的更新，跟 MoCo 的想法是非常一致的

另外设置里面超参数的设定，比如说算 loss 的时候温度的设置是0.07，选了4,000个负样本，训练是200个epochs，batch size  是256，起始的 learning rate 是0.03，之后其它论文（尤其是 MoCo）所有的这些实验细节，MoCo 都是严格按照  Inst Disc  来的，这些超参数都没有进行更改。所以说 Inst Disc 这篇论文也是一个里程碑式的工作：它不仅提出了个体判别这个代理任务，而且用这个代理任务和 NCE loss做对比学习，从而取得了不错的无监督表征学习的结果，同时它还提出了用别的数据结构存储这种大量的负样本，以及如何对特征进行动量的更新，所以真的是对后来对比学习的工作起到了至关重要的推进作用





Unsupervised Embedding Learning via Invariant and Spreading Instance Feature 






这是一篇 CVPR 19的论文,跟今天要说的其它论文相比,它的影响力可能不是那么大，之所以提一下这篇论文，是因为它可以被理解成

是 SimCLR 的一个前身，它没有使用额外的数据结构去存储大量的负样本，它的正负样本就是来自于同一个 minibach，而且它只用一个编码器进行端到端的学习



这篇文章也没有给自己起名字，所以就像 Inst Disc 一样就叫它  Inva Spread  好了，所以写论文的时候，最好还是给自己的方法起个名字，而不是叫 ours，这样方便别人记住也方便别人引用，也是一个双赢的事情



本文的想法其实就是最基本的对比学习


如图1所示，同样的图片通过编码器以后，它的特征应该很类似，不同的图片，它的特征出来就应该不类似，这就是题目中说的invariant和 spreading，就是说对于相似的图片、相似的物体，特征应该保持不变性，但是对于不相似的物体或者完全不沾边的物体，特征应该尽可能的分散开
具体做法：


代理任务也是选取了个体判别这个任务
前向过程：

如果 batch size 是256，也就是说一共有256个图片，经过数据增强，又得到了256张图片
对于 x1 这张图片来说， x1' 就是它的正样本，它的负样本是所有剩下的这些图片（包括原始的图片以及经过数据增强后的图片），也就是说正样本是256，负样本是256减1*2，就是除去样本本身之外 mini-batch 剩下的所有样本以及它经过数据增强后的样本，也就是这里为什么要*2，这些都是负样本
它和 Inst Disc d的区别：Inst Disc中，正样本虽然是256，它的负样本是从一个 memory bank 里抽出来的，它用的负样本是4096甚至还可以更大
本文为什么要从同一个  mini-batch  里去选正负样本？因为这样就可以用一个编码器做端到端的训练了，这也就是MoCo里讲过的端到端的学习方式
剩下的前向过程都是差不多的，就是过完编码器以后，再过一层全连接层就把这个特征的维度降的很低，就变成128了，正样本比如说上图中绿色的球在最后的特征空间上应该尽可能的接近，但是这个绿色的球跟别的颜色的特征应该尽可能的拉远
本文所用的目标函数也是 NCE loss 的一个变体
所以说之所以讲这篇论文，是因为它刚好属于另一个流派，也就是端到端的学习，而且只用一个编码器，不需要借助外部的数据结构去存储大量的负样本，它的正负样本都来自于同一个 minibach
既然它跟 SimCLR 这么像，为什么它没有取得那么好的结果呢？就是之前在MoCo那篇论文里反复强调过的，就是这个字典必须足够大，也就是说在做对比学习的时候，负样本最好是足够多，而本文的作者是没有 TPU 的，所以说它的 batch size 就是256，也就意味着它的负样本只有500多个，再加上它还缺少像  SimCLR  那样那么强大的数据增广以及最后提出的那个 mlp projector，所以说呢这篇论文的结果没有那么炸裂，自然也就没有吸引大量的关注，但事实上它是可以理解成  SimCLR  的前身




Representation Learning with Contrastive Predictive Coding



CPC(contrastive predictive coding)



一般机器学习分为判别式模型和生成式模型，个体判别显然是属于判别式范畴的，那肯定就会有一些生成式的代理任务，比如最常见的预测型的任务



cpc 这篇论文其实非常厉害，因为它是一个很通用的结构




图1中描述的是CPC不仅可以处理音频，还可以处理图片、文字以及在强化学习里使用
这里为了简单，它用的是一个音频的信号作为输入
本文的想法：假如说有一个输入 x（一个持续的序列），t表示当前时刻，t-i表示过去的时刻，t+i表示未来的时刻。把之前时刻的输入全都扔给一个编码器，这个编码器就会返回一些特征，然后把这些特征喂给一个自回归的模型（gar，auto regressive），一般常见的自回归模型，就是 RNN 或者 LSTM的模型，所以每一步最后的输出，就会得到图中红色的方块（ct，context representation，代表上下文的一个特征表示），如果这个上下文的特征表示足够好（它真的包含了当前和之前所有的这些信息），那它应该可以做出一些合理的预测，所以就可以用ct预测未来时刻的这个zt +1、zt + 2（未来时刻的特征输出）
对比学习在哪里体现的呢？正样本其实就是未来的输入通过编码器以后得到的未来时刻的特征输出，这相当于做的预测是 query，而真正未来时刻的输出是由输入决定的，也就是说它们相对于预测来说是正样本；负样本的定义其实很广泛，比如可以任意选取输入通过这个编码器得到输出，它都应该跟预测是不相似的，这就是cpc定义正负样本的方式
这套思想是很朴实的，把输入序列换成一个句子，也可以说用前面的单词来预测后面的单词的特征输出；如果把这个序列想象成一个图片的patch块从左上到右下形成一个序列，就可以用上半部分的图片特征去预测后半部分的图片特征，总之是非常灵活




Contrastive Multiview Coding



CMC(contrastive multiview coding)



 cpc是用预测的代理任务做对比学习



cmc这篇论文定义正样本的方式就更为广泛了：一个物体的很多个视角都可以被当做正样本



cmc 的摘要写的非常好：

人观察这个世界是通过很多个传感器，比如说眼睛或者耳朵都充当着不同的传感器来给大脑提供不同的信号
每一个视角都是带有噪声的，而且有可能是不完整的，但是最重要的那些信息其实是在所有的这些视角中间共享，比如说基础的物理定律、几何形状或者说它们的语音信息都是共享的
在这里举了个很好的例子：比如一个狗既可以被看见，也可以被听到或者被感受到
基于这个现象作者就提出：他想要学一个非常强大的特征，它具有视角的不变性（不管看哪个视角，到底是看到了一只狗，还是听到了狗叫声，都能判断出这是个狗）
cmc工作的目的就是去增大互信息（所有的视角之间的互信息）
如果能学到一种特征能够抓住所有视角下的关键的因素，那这个特征就很好了，至少解决分类问题不在话下



cmc到底是怎么样去形成正样本和负样本从而去做对比学习的呢？如图一所示，它选取的是  NYU RGBD 这个数据集（这个数据集有同时4个view，也就是有四个视角：原始的图像、这个图像对应的深度信息（每个物体离观察者到底有多远）、SwAV ace normal、这个物体的分割图像）
cmc 的意思是说，虽然这些不同的输入来自于不同的传感器或者说不同的模态，但是所有的这些输入其实对应的都是一整图片，都是一个东西，那它们就应该互为正样本，也就是说，当有一个特征空间的时候，比如图中圆圈所示的特征空间，这四个绿色的点在这个特征空间里就应该非常的接近。这时候如果随机再去挑一张图片，不论是用图片还是用风格的图像（总之属于一个不配对的视角）的话，这个特征就应该跟这些绿色的特征远离
这就是 cmc 定义正负样本的方式，它的正样本来自于多个视角，一旦定义好了正负样本，剩下的工作就大差不差了
 cmc是第一个或者说比较早的工作去做这种多视角的对比学习，它不仅证明了对比学习的灵活性，而且证明了这种多视角、多模态的这种可行性。所以说接下来open AI，很快就出了clip模型：也就是说如果有一个图片，还有一个描述这个图片的文本，那这个图像和文本就可以当成是一个正样本对，就可以拿来做多模态的对比学习
cmc原班作者人马用对比学习的思想做了一篇蒸馏的工作：不论用什么网络，不论这个网络是好是坏是大是小，只要你的输入是同一张图片，那得到的这个特征就应该尽可能的类似，也就意味着想让 teacher 模型的输出跟 student 模型的输出尽可能的相似，它就通过这种方式把 teacher和student做成了一个正样本对，从而可以做对比学习
所以说让大家意识到对比学习如此灵活，可以应用到不同的领域，cmc功不可没
一个小小的局限性：当处理不同的视角或者说不同的模态时候，可能需要不同的编码器，因为不同的输入可能长得很不一样，这就有可能会导致使用几个视角，有可能就得配几个编码器，在训练的时候这个计算代价就有点高（比如说在 clip 这篇论文里，它的文本端就是用一个大型的语言模型，比如说 bert，它的图像端就是用一个 vit，就需要有两个编码器），这样其实又回到了刚开始讲ViT时候所说的说这个Transformer的好处--Transformer有可能能同时处理不同模态的数据
事实上现在已经有人这么做了，今年的ICLR就有一篇ma clip，它就用一个Transformer去同时处理两个输入模态，效果反而更好，所以说这可能才是 Transformer 真正吸引人的地方：一个网络能处理很多类型的数据，而不用做针对每个数据特有的改进




第一阶段大概讲了这四篇论文，可以看到

它们使用的代理任务是不一样的，有个体判别，有预测未来，还有多视角多模态
它们使用的目标函数也不尽相同，有 NCE，有infoNCE，还有NCE的其它变体
它们使用的模型也都不一样，比如说invariant spread用了一个编码器；Inst Disc用一个编码器和memory bank；cpc有一个编码器，还有一个自回归模型；cmc可能有两个甚至多个编码器
它们做的任务从图像到视频到音频到文字到强化学习，非常的丰富多彩








2、CV双雄



这里之所以是双雄，其实主要想讲的是MoCo和SimCLR 



Momentum Contrast for Unsupervised Visual Representation Learning



MoCo 



这次主要就讲和其它工作的区别和联系



MoCo 的主要贡献就是把之前对比学习的一些方法都归纳总结成了一个字典查询的问题，它提出了两个东西

队列
动量编码器
从而去形成一个又大又一致的字典，能帮助更好的对比学习



MoCo跟Inst Disc是非常相似的

它用队列取代了原来的memory bank作为一个额外的数据结构去存储负样本
它用动量编码器去取代了原来loss里的约束项，从而能达到动量的更新编码器的目的，而不是动量的去更新特征，从而能得到更好的结果
但是整体的出发点以及一些实现的细节都是非常类似的

 MoCo 的这个实现细节：

首先从模型的角度上来说，它用的是残差网络，它的基线模型都用的是Res 50，其实Inst Disc也用的是Res 50，模型上是一样的
最后每个图片的特征维度也沿用了128维
它也对所有的特征做了L2 归一化
至于目标函数，MoCo 采用的是info NCE，而不是像Inst Disc是NCE但是算loss用的温度也是0.07
数据增强的方式也是直接借鉴过来的
包括后面训练的学习率0.03，训练200个epochs这些也都是跟Inst Disc保持一致的
所以，说MoCo是Inst Disc一个改进型工作也不为过，但是MoCo真正出色的地方其实有两点

一个是它的改进真的是简单有效，而且有很大的影响力的，比如说它的动量编码器，在后面的SimCLR、BYOL，一直到最新的对比学习的工作都还在使用。它提出的这个技术不仅在当时帮助 MoCo第一次证明了无监督学习也能比有监督特征学习的预训练模型好，而且还能产生持续的影响力，帮助之后的工作取得更好的结果，所以它的改进很深刻而且很有效
另外一个可圈可点的地方就是MoCo的写作真的是高人一等非常不一样，其实如果是一个简单直白的写作方式，在语言里先介绍对比学习是什么，然后再介绍之前的工作有哪些，比如说有端到端的工作，然后有看Inst Disc，这个 memory bank 的这个工作，然后它们各自都有各自的缺点和局限性，所以说提出MoCo ，用队列去解决大字典的问题，用动量编码器去解决字典特征不一致的问题，最后结果很好，第一次证明了在下游任务中用一个无监督训预训练的模型也会比有监督预训练的模型好，那这种写法也是一种很简洁直白明了的写作方式，大部分论文的写作都是按照这个套路来的。但是MoCo的作者明显就高了一个层次：引言上来先说这个cv和nlp之间的区别，以及到底为什么无监督学习在 cv 这边做的不好，然后第二段它才开始讲对比学习，但是它也不是细细地去讲对比学习，或者细细的去讲那些方法，而是直接把之前所有的方法都总结成了一个字典查找的问题，所以直接把问题给归纳升华了，然后在这个框架下，就是 cv 和 nlp 大一统的框架以及所有的对比学习也都大一统的框架之下，然后作者提出了 MoCo 这个框架，希望能用一个又大又一致的字典去整体地提高对比学习的性能，那论文的scope整体就扩大了，远不是之前的那种简单的写作方式可以比的，而且这样的写作风格呢还延续到了方法部分，在3.1里，作者没有先写一个模型总览图，也没有具体说是什么模型、什么任务，而是先从最后的目标函数入手，说是用info  NCE来做的，先把正负样本定义了一下，然后再去讲网络结构然后再去讲实现细节和伪代码，而且在3.1里，为了让MoCo看起来更朴实，在这里没有直接定义输入是什么，也没有定义这个网络结构到底是什么样的，它是说什么样的输入都可以，比如说它可以是图片，也可以是图片块，或者是上下文的图片块（文献46其实就是cpc），至于网络，它说query 的编码器和key的编码器既可以是相同的（invariant spread），也可以是部分共享的，还可以是完全不同的（文献56就是cmc，因为是多个视角嘛所以是多个编码器）
所以说MoCo这种自顶向下的写作方式也是非常值得借鉴的，但这个真的是需要功力，稍有把握不慎别人可能就看不懂了





A Simple Framework for Contrastive Learning of Visual Representations 



SimCLR(simple contrastive learning)



这个方法真的是够简单，这就是为什么很多博客在介绍对比学习的时候都用SimCLR当例子，因为它概念上更容易理解，方法上也很容易解释，只不过batch size太大，一般人不好上手




图二里说，如果有一个mini-batch的图片，假如说是x，对这个mini-batch里的所有图片做不同的数据增强就会得到x i和xj，同一个图片延伸得到的两个图片就是正样本，也就是说如果batch size是n的话，正样本个数就是n，负样本的个数就是这个 batch size 剩下所有的样本以及它们数据增强过后的样本，也就和invariant spread里讲的一样，是两倍的 n 减1
然后当有了正负样本之后通过编码器f对它进行编码，这两f是共享权重，也就说其实只有一个编码器，如果把它想象成一个 res 50的话，得到的h（特征表示）是2048维了
 SimCLR的重大创新点其实是在特征之后又加了一个projector，也就是上图中的g函数，它就是一个mlp层（只有一个全连接层，后面跟一个 relu 的激活函数），但是就这么简简单单的一层mlp能让最后学到的特征在ImageNet 这个分类任务上直接提点将近10个点，这个效果在别的任何的任务里或者说在有监督学习里是很难观测到的，很少有说加一个全连接层就能直接提点10个点，所以说是一个非常有趣而且非常惊讶的结果
但是在这个框架里，可以想象出有一个特征之后再做一个非线性变化，就得到了另外一个特征，也就是最后去做对比学习的那个特征，一般这个特征z，它的维度会小一点，为了跟之前的工作保持一致性，它也用了128维
最后要衡量一下正样本之间是不是能达到最大的一致性，它采用的是normalized temperature-scaled的交叉熵函数。normalized就是说在这个特征后面进行了 L2 归一化，temperature-scaled  就是说在这个 loss 成了个tao，所以说其实这个loss跟之前说的infoNCE loss也是非常接近的
g函数只有在训练的时候才用，而在做下游任务的时候，是把g函数扔掉了，还是只用h这个特征去做下游任务，这样的话跟之前的工作也还是公平对比，因为之前它们如果用 res 50，还是用 res 50并没有多加一层，加上这个g函数只是为了能让模型训练的更好


和MoCo比起来确实很简单，这里只有一个编码器，既不需要memory bank，也不需要队列和动量编码器；正负样本全都是从同一个mini-batch里来的；整个前向过程非常的直接，就是图片进入编码器编码然后projector降维，最后算个对比学习的loss，非常符合大家对深度学习工作的期待



前面说invariant spread可以看作是SimCLR的前身，为什么这么说呢？本文其实整体的这个思路和结构跟SimCLR是基本一致的，SimCLR跟Inva Spread的区别其实都写在SimCLR的贡献列表里了

首先第一个就是它用了更多的数据增强，它发现对比学习真的是需要很强的数据增强的技术
第二就是它加了一个g函数（一个可以学习的分线性的变换，就是一个 mlp层）
第三就是它们用了更大的batch size ，而且训练的时间更久，它发现这两个策略都能让网络学到的特征变得更好
乍一看这些贡献有些读者可能就会觉得这些技术不都或多或少在之前的工作里被提出来过吗？所以说在这篇论文里，作者专门把相关工作放到了第七节，相当于文章的最后才去讲相关工作，它比较细致的跟之前手工的代理任务做了对比，然后跟最近的对比学习也做了对比，而且作者最后非常谦虚的写了这么一段话：就是说基本上所有的这些单个的这些贡献在之前的工作里都被提出来过了，虽然有的时候这个实现的形式可能不太一样，但是作者强调说SimCLR 的优越之处就是在于它的成功不是由任何一个单一的设计决定，而是把所有的这些技术结合起来而得到的一个结果，而且作者把详细的消融实验，以及它们的设计选择全都放到了附录里，所以说作者团队真的是非常贴心，而且非常谦虚了

而事实上呢，SimCLR这篇文章中提出来的很多技术都对后续的工作产生了长远的影响力，比如说在编码器之后加这么一个mlp层，在之后的MoCo v2、BYOL这些工作里全都有使用；它使用的数据增强的策略在之后的工作里也是被广泛的使用；它使用lars这个优化器去做大batch size的这个模型训练，之后BYOL 也采用了同样的策略。总之SimCLR真的是够简单，而且为后续的很多研究铺平了道路





最后稍微讲一下SimCLR这篇论文里的贡献

第一个就是数据增强

如下图图4所示，SimCLR这篇论文使用了这么多的数据增强的方法，从最开始的原始图片，到裁剪，到改变色彩，到旋转，使用 cut out，还有使用高斯的噪声和高斯 blur，以及最后使用sobel的这种滤波器。真的是把前人想到的这些数据增强的方式全都用了个遍，然后为了让读者知道，到底哪些数据增强有用，哪些数据增强没用，作者还做了详细的这个消融实验

下图中除了最后一列是 average，剩下的数字就是这七种数据增强两两互相合并之后的这个效果如何，比如说中间的对角线其实就是使用一个数据增强，发现其实最有效的两个数据增强就是这个crop和这个color，也就是随机的裁剪和随机的这种色彩变换，其它的数据增强其实最后都是锦上添花、可有可无的，但这两个是必须得有的
另外一个就是说SimCLR这篇文章提出的非线性变换，也就是说在编码器后面加一层mlp

如图8所示，如果h是一个res 50出来的特征，也就是2048维的话，那z就是经过了projector之后的维度，一般是128


g函数其实里面就包含了一个全连接层和一个 relu 激活函数
projection head指的是non-linear，之所以是 non-linear是因为有relu的激活层（relu就会把一个线性函数变成非线性）
linear线性指的是不要relu，只加一层全连接层就可以了
None其实就是说像Inva Spread或者像MoCo一样，直接编码器出来的特征拿去做对比学习，不要projection head
然后会发现两个很有意思的现象

第一个就是如果用non-linear的层，相比原来什么都不用，结果提了十几个点，所以是非常显著的
第二个就是说z最后的维度不论是32、64还是2048其实都没太大区别，这就是为什么对比学习现在一般都选一个比较低的特征维度，因为128就够了，再高再低其实最后的结果也没有太大的变化
因为这里提升10个点实在是太过诡异，所以作者还做了很多实验

去验证这个想法，比如说在表3里就做了一些实验，但是也仅仅是一些实验，并不一定能真的证明这个事，至今好像也没有一个理论上的解释





Improved Baselines With Momentum Contrastive Learning



因为MoCo和SimCLR的结果实在是太过惊艳，所以从2020年开始就掀起了一波对比学习的狂潮，基本上每天只要去刷arxiv，都会有对比学习的论文，这波热浪一直到20年年底Vision Transformer出来以后才逐渐消退



MoCo v2其实是一个只有两页的技术报告，严格意义上不算是一篇论文了，但即使只有两页，信息量也是相当大



MoCo v2主要就是说，在看到SimCLR这个比较好的结果以后，它们发现SimCLR里的那些技术都是即插即用型的，所以说它们就把那些就拿过来了，它直接说，就在MoCo上面做很简单的改动，引入了mlp projection head以及使用更多的数据增强，就又刷新ImageNet 上的最好成绩，不仅比之前的MoCo高很多，而且比最新的SimCLR也要高很多



注意，SimCLR是2月13号才放到arxiv上的，MoCo v2是3月9号就放到arxiv上了，所以说这个节奏是相当快的



MoCo v2 具体进行了哪些改进？如下表表1所示


准确的说就四个方面

加了一个 mlp 层
加了更多的数据增强
训练的时候用了cosine的learning rate schedule
训练更长的 epoch，从200变到了800
ImageNet 上结果

灰色的结果76.5属于是有监督的这个基线模型
MoCo v 1只能达到60.6，差的还是比较远的
就在上面加上这个projection head mlp层，一下准确率就提高到66.2，就长了6个点，所以说加projection head 不光是对 SimCLR  有用，对MoCo也有用，其实对其之后的很多方法都有用，像SwAV呢也用了，BYOL也用了
如果使用更强的数据增强，就是也能提三个点，从60到63，但是不如mlp提升的多
如果把这个mlp 和augmentation一起用就已经到67.3了，就非常高了
再加上这个cos的这个学习率，就到67.5还能再提0.2个点，那这个提升就很小了可以忽略不计
最后如果训练更长的时间，训练800 epochs，就能再提高到71.1，SimCLR结果也是这样，如果它训练更久的话，它的结果也会提升很多，一直到现在为止，就连凯明最新的MAE这个工作，也是训练了1,600个epochs，而且的这个效果还在继续往上涨
无监督学习真的是训练的越久或者模型越大，它的结果就会越好



接下来作者主要跟SOTA进行了比较，其实也就是MoCov1和 SimCLR这些工作，如下表表2所示


在只训练200epochs的情况下，MoCo v2比SimCLR高了大概一个点
如果训练更长的时间，在训练800个epochs的时候MoCo v2能到71.1，比SimCLR训练了1,000个epochs还要好将近2个点，所以就意味着MoCo v2能更好的利用数据，能在更短的时间内取得更好的结果
接下来作者又再次强调了一下为什么要用MoCo以及MoCo相比于SimCLR的优越性如上图中表3所示：

其实这个优越性就在于硬件：机器的内存以及训练的时长
MoCo v2的作者使用的机器配置是8张v 100的显卡，MoCo在普通这个batch size 256的情况下就能训练，内存只消耗5个G，其实还有很多的剩余空间，还可以再加大batch size或者再增大模型都可以，它非常省内存，而且训练一个模型也只需要53个小时，在ImageNet这种规模的数据集上来说，两天多的时间已经算是很快了
如果这个时候换成end-to-end这种端到端的学习，也就之前说的invariant spread或者SimCLR，这里主要指的就是SimCLR 我们如果只用小batch size是256的时候，SimCLR在小 batch size的情况下只有61.9的结果
相对MoCo v2来说就差很多了，为什么呢？因为字典不够大、提供的负样本不够多，所以导致对比学习对比不是很有效，而且不光是效果低，它的内存占用7.4 G也明显高，训练的时长也多了十几个小时，就是全方位呢都不划算
如果想要端到端的这个学习走4096的这个batch size就是说让它的performance变好，变成66.6，虽然说还没有MoCo v2好，但也差不多，性能上比较相近，那它对硬件的要求就太高了

比如说对 gpu 的这个内存要求，它需要93个g的内存，这里画了个脚注，意思就是说这只是估计，因为现在也没有这么大内存的gpu，所以说它只能估计一下，训练时长当然也就不得而知了
因为这种端到端的学习方式，包括SimCLR、BYOL、SwAV默认都是用8台8卡机去做训练的,也就是有64张gpu,才能在一两天这个合理的时间内把训练完成，而MoCo只需要一台8卡机就可以在两天的时间内完成





Big Self-Supervised Models are Strong Semi-Supervised Learners



SimCLR  v2



其实SimCLR  v2，只是这篇论文一个很小的部分，它只是说怎么从v1变到v2，就是一个模型上的改进，而事实上都在讲如何去做半监督的学习



它主要想说的体现在它的这个标题里了：非常大的自监督训练出来的模型非常适合去做半监督学习



模型总览图如下图中图3所示


这篇文章分了三个部分

第一部分就是SimCLR，怎样自监督或者说自监督的对比学习去训练一个大的模型出来
第二部分就是说，一旦有了这么好的一个模型，只需要一小部分有标签的数据，然后去做一下有监督的微调，一旦微调结束了，就相当于有一个 teacher 模型，就可以用这个teacher模型去生成很多伪标签，这样就可以在更多的无标签的数据上去做自学习了
整个框架其实也是受启发于google的另外一篇工作（19年的一篇叫

noisy student 的工作）

因为noisy student就是在ImageNet数据集上先训练了一个 teacher 模型，然后在JFT 300M那个数据集上生成了很多的伪标签，最后一起训练了一个student模型，而这个 student 的模型算是  ImageNet  上的SOTA，大概是88点多的准确率，霸占了ImageNet上这个sota很长时间，大概有一年的时间
 Vision Transformer就跟这个 noisy student 比过，因为截止到那个时候，noisy student还是ImageNet上的 SOTA 


作者其实就在第三页大概花了半页的篇幅来讲了一讲怎么把v1变成v2了，其实大概就是提高了这三个点：

第一个就是大家其实都公认的一个事实，就是用更大的模型，无监督训练就会训练的更好，在这里就换了一个更大的模型，换了一个152层的残差网络，同时用了这个selective kernels，也就是SK net，这个骨干网络变得非常的强
第二点改进就是，之前SimCLR说protection head的mlp层特别有用，而且MoCo v2也证明了特别特别的有用，所以SimCLR的作者就想那一层都这么有用了，把它再变深点会不会更有用，所以它就试了试变成两层变成三层这个性能会不会继续提升，最后发现其实就是两层就够了，原来是 fc + relu，现在是 fc + relu fc + relu，一层变成两层的 mlp，这个效果呢就最好了，就是加深了这个projection head
第三点改进就是它们也使用了动量编码器（这里说 motivated  by 29，就是MoCo v2 ，20就是 MoCo），就是SimCLR的作者发现MoCo 的这个动量编码器真的很管用，所以也想试一试，事实上动量编码器真的管用，后面BYOL 都用了动量编码器，但在这里作者说动量编码器在SimCLR 里的提升并不是很大可能就提了一个点，具体原因它们解释说，因为它们已经有非常大的这个mini-batch，要么是4096，要么是8192，所以它们的负样本已经相当多了，所以不论是从字典的大小，还是从字典里特征一致性来说，SimCLR v2 都已经做的很好了，所以说再加这种队列或者加这种动量编码器其实都不会带来很大的提升
总的来说就是三点改进：

使用了更大的模型
加深了projection head
引入了动量编码器


如果不算半监督学习的内容的话，SimCLR v2也是一个2页的技术报告，而且不论是SimCLR v1还是v2，都只做了分类这个任务，但是MoCo就广泛的很多了，至少做了四五个下游的任务，而且刷了很多的数据集，所以MoCo系列工作就更cv friendly，所以它投的都是cv的会议，而SimCLR  v1就是 ICML，而SimCLR  v2就是 Neural IPS，所以说投对口的会议也很重要









Unsupervised Learning of Visual Features by Contrasting Cluster Assignment



SwAV

Swap
assignment
views
给定同样一张图片，如果生成不同的视角，不同的 views 的话，希望可以用一个视角得到的特征去预测另外一个视角得到的特征，因为所有这些视角的特征按道理来说都应该是非常接近的



本文的具体的做法就是把对比学习和之前的聚类的方法合在了一起，当然这么想也不是偶然

首先，聚类方法也是一种无监督的特征表示学习方式，而且呢它也是希望相似的物体都聚集在某一个聚类中心附近，不相似的物体尽量推开推到别的聚类中心，所以跟对比学习的目标和做法都比较接近
另外，这篇文章的一作其实之前一直也是做聚类的，它之前就做过deep cluster这篇工作，也是一篇非常好的无监督学习的论文


具体 SwAV  是怎么和聚类的方法融合起来的呢？


上图图1把之前对比学习的方法总结了一下画到了左边，然后把SwAV的方法画到了右边，这样就比较好对比
左边当然很好理解了，就是同一个图片，做两次数据增强就得到了x1、x 2，然后所有的样本通过一个编码器，这个编码器有可能就是个 Res 50，也有可能是一个 Res 50加了一个  projection head，它这里没有明说，反正就是所有的这些都属于一个模型，最后这个模型输出一个特征，一旦有了这个特征，用它做一个对比学习的 loss 就可以了
SwAV说，这么做虽然比较简单，但是直接拿所有图片的特征跟特征做对比有点原始而且有点费资源，因为所有的图片都是自己的类，所以其实像MoCo一样，取了6万个负样本，这还只是个近似，因为其实所有的数据集，所有的负样本理应是128万个图片
SwAV的作者就想，能不能不去做近似，能不能借助一些先验信息不去跟大量的负样本比，而去跟一些更简洁的东西比，然后SwAV的作者就想出来了，可以去跟聚类的中心比（聚类中心就是右图里的c，也就是个prototype，它其实就是个矩阵，它的维度是d 乘以 k，d是特征的维度，这里的d和特征的d 是一样的，比如说就是之前说的128维，这个k就是有多少个聚类中心，在这篇文章中它们选的是3,000，也就是说你有3,000个 cluster center，3,000这个数字也是之前的一些聚类方法在ImageNet数据集上常用的一个参数）
SwAV的前向过程

前面还是都一样的：一个mini-batch的图片，做两次数据增强，得到x1、x2分别通过编码器得到最后的特征z1、z2
有了z1、z2之后并不是直接在这个特征上去做对比学习的loss，而是说先通过clustering让特征z和prototype c生成一个目标，也就是这里的q1、q 2
q1、q2就相当于ground truth，那它真正要做的这个代理任务是什么呢？它的意思是说如果x1、x2是正样本的话，那z1 和 z 2的特征就应该很相似，也就跟之前对比学习一样，z1和z2要尽可能的相似
那如果两个特征非常相似，或者说含有等量的信息的时候，按道理来说应该是可以互相去做预测的，也就是说，如果拿z1这个特征去跟c去做点乘，按道理来说也是可以去预测q2；反之亦然，z2和这个c去做点乘也可以预测q1，所以说点乘之后的结果就是预测，而ground truth就是之前按照clustering分类而得到的q1和q2
所以通过这种Swapped prediction，也就是换位预测的方法，SwAV可以对模型进行训练
用聚类的好处到底有哪些？

首先，就像SwAV 这篇论文里讲过的一样，如果要跟很多的负样本去做类比，可能就需要成千上万的负样本，而且即使如此也只是一个近似，而如果只是跟聚类中心做对比，则可以用几百或者最多3,000个聚类中心，就足以表示了，因为其实也并没有那么多类，ImageNet也就1,000类，COCO才80类，所以说 3,000个聚类中心就足够用了，这相对于几万个负样本来说还是小了很多的
第二，这些聚类中心是有明确的语意含义的，如果之前只是随机抽样抽取负样本去做对比的话，那些负样本有的可能还是正样的，而且有的时候抽出来的负样本类别也不均衡，所以不如使用聚类中心有效。其实这就是SwAV的基本思想。（如果对聚类算法比较感兴趣，以先去看deep cluster deep cluster two，然后再来看这篇 SwAV 的论文）

SwAV的结果非常好，它不仅比我们之前讲过的方法效果好，其实比之后要讲的BYOL、SimSiam这些都好，算是卷积神经网络里用Res 50分刷的最高的一篇工作，达到了75.3
上图表里的性能做的还是ImageNet的linear evaluation，也就之前说的提前预训练好一个模型以后，把这个模型的backbone冻住，只训练最后的那个全连接层
表中之前不是对比学习的方法都还比较低，可能都是在60以下，有了对比学习以后，从 MoCo 开始基本上就上60了，然后CPC v2刷到63.8，SimCLR刷到70，MoCo v2刷到71.1，之后要讲的BYOL其实74点几，SimSiam也是74点几
所以说75.3就算是最高的了，而且这个75.3是你把backbone冻住的情况下去做的，如果跟有监督的基线模型去比的话，这个有监督的基线模型是从头到尾都在ImageNet 上训练，最后的结果也就是76.5，所以说SwAV 已经是非常非常逼近这个结果
而且当使用更大的模型的时候，也就是像右图里说的一样，把一个Res 50变宽，而且就是这里的2倍、4倍、5倍这么宽的时候，SwAV的结果还能不停地涨
当用最大的模型（5倍的模型）的时候，SwAV已经跟有监督的模型，差距非常的小，而且SwAV也是要比SimCLR *2、SimCLR 4要高的，所以说从性能上来讲，SwAV 是真的不错

但其实让SwAV有这么好的性能，不光是因为它和聚类的方法融合在了一起，它另外一个主要的性能提升点来自于一个叫multi crop的trick：

之前的那些对比的学习方法都是用的两个crop，也就是说一个正样本对x1、x2两个图片，如上图左下角所示，本来我们有一个图片，先把它resize 到256*256，然后随机crop两个224*224的图片当成 x1 x2，因为这两张图片都非常大，所以它们重叠的区域也非常多，于是它们就应该代表一个正样本
但总之就是两个 crop，SwAV的作者就想：用这么大的crop明显抓住的是整个场景的特征，如果更想学习这些局部物体的特征，最好能多个 crop，去图片里crop一些区域，这样就能关注到一些局部的物体了
但是增加crop，也就是说增加view，会增加模型的计算复杂度，因为相当于使用了更多的正样本
那如何能同时使用更多的正样本，而又不增加太多的这个计算成本呢？作者就想到了另外一个办法，就是说做点取舍，原来是取了两个224*224的crop，现在把这个crop变得小一点，变成160 ，也就是说取2个160的crop去争取学全局的特征，然后为了增加正样本的数量，为了学一些局部的特征，再去随机选4个小一点crop，然而这4个crop的大小是96*96，这样的话，就意味着现在有6个视角了，而不是像原来一样只有2个视角，所以正样本的数量增多了，但是通过这么一种取舍，整体的计算代价还是差不多的
别看这个想法很简单，这个multi crop的技术真的很有用而且它不光是对SwAV有用，对其它的对比学习的方法也有用
作者在下图图3中就做了一些实验


基线模型就是2*224，它用了  multi crop 的这个技术，就是2*160加上4*96
如果现在把multi crop的技术用到SimCLR上会发现它涨了2.4个点，这个涨幅还是非常明显，所以说其实如果把 multi crop这个技术用到 BYOL 上有可能BYOL会比SwAV的效果高
接下来作者又对比了一些聚类的方法，对于聚类的这些方法用multi crop的方式提点就更多了，对于这几个方式来说都提了四个多点，更是非常显著
所以我们可以看到，如果没有这个multi crop的这个技术，把这四个点拿掉，其实SwAV的性能也就跟MoCo v2是差不多的，也就是说一个纯聚类的方法，或者说聚类和对比学习结合的方法其实也并没有什么优势，真正提点的是multi crop的技术
multi crop这个技术其实非常朴实了，它其实就是一种思想，就是说全局的和这个局部的特征都要关注，所以说接下来的很多工作，也都借鉴是multi crop的这个技术，而不是 SwAV 这篇工作本身




这里简单提一下：



CPC v2其实也是融合了很多的技巧，它用了更大的模型、用了更大的图像块、做了更多方向上的预测任务，把batch norm 换成了 layer norm，而使用了更多的数据增强，所以这一系列操作下来，CPC v2直接就把CPC v1之前在 ImageNet 上40多的准确率一下就拔到70多



informing其实是 cmc 的作者做的一个分析型的延伸性工作，它论文本身的名字叫 What Makes for Good Views for Contrastive Learning（我们到底选什么样的视角才能对对比学习最好？）

它主要是提出了一个InfoMin的原则，就是最小化互信息minimi mutual information，那乍一听觉得可能有点奇怪，因为之前大家做的都是 maximize mutual information，都是想要两个视角之间的互信息达到最大，为什么作者这里就想让它达到最小呢？
其实这里也不是严格意义上的最小，作者其实想说的是，他想要不多不少的互信息，如果最大化互信息以后比所需要的互信息要多，也是一种浪费，而且有可能泛化做的不好，但如果互信息比所需求的这个互信息要少，有可能达不到最优的性能，所以这个才是作者的本意，就是不能一味的最大化这个互信息，而是要不多不少刚刚好
然后按照Info Min的原则选择合适的数据增强，然后拿到合适的对比学习的视角以后，作者发现对于很多的方法都有提升，它们最后在 ImageNet 上也有73，也是相当不错的


总结：



其实到了第二阶段很多细节都处于统一了，比如说

目标函数都是用infoNCE或者infoNCE类似的目标函数去算的
模型最后也都归一到用一个编码器后面加一个projection head
都采用了更强的数据增强
都想用这个动量编码器
都尝试着训练的更久
最后在ImageNet上的准确度也逐渐逼近于有监督的基线模型








----to be continued---- 作者：如果我是泡橘子 https://www.bilibili.com/read/cv14700928/?from=readlist&jump_opus=1 出处：bilibili